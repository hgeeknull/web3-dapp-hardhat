### solç¬”è®°
#### ç±»å‹ï¼ˆTypesï¼‰
##### å€¼ç±»å‹
01. å¸ƒå°”ç±»å‹
02. æ•´å‹
03. å®šé•¿æµ®ç‚¹å‹
04. åœ°å€ç±»å‹
    - åœ°å€ç±»å‹å­˜å‚¨ä¸€ä¸ª**20å­—èŠ‚**çš„å€¼
    - åœ°å€ç±»å‹æˆå‘˜å˜é‡ï¼š`balance`å’Œ`transfer`; `send`; `call`ï¼Œ F å’Œ `delegatecall`
    - callå‡½æ•°ï¼šå¯ä»¥æ¥å—ä»»æ„ç±»å‹ä»»æ„æ•°é‡å‚æ•°ã€‚è¿™äº›å‚æ•°ä¼šè¢«æ‰“åŒ…åˆ°**ä»¥32å­—èŠ‚ä¸ºå•ä½**çš„è¿ç»­åŒºåŸŸä¸­å­˜æ”¾ã€‚ å…¶ä¸­ä¸€ä¸ªä¾‹å¤–æ˜¯å½“**ç¬¬ä¸€ä¸ªå‚æ•°è¢«ç¼–ç æˆæ­£å¥½ 4 ä¸ªå­—èŠ‚**çš„æƒ…å†µã€‚
        > address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
        > nameReg.call(bytes4(keccak256("fun(uint256)")), a);
    - `delegatecall` çš„ç›®çš„æ˜¯ä½¿ç”¨å­˜å‚¨åœ¨å¦å¤–ä¸€ä¸ªåˆçº¦ä¸­çš„åº“ä»£ç 
    - ä¸é¼“åŠ±ä½¿ç”¨ `callcode`ï¼Œåœ¨æœªæ¥ä¹Ÿä¼šå°†å…¶ç§»é™¤ã€‚
05. å®šé•¿å­—èŠ‚æ•°ç»„
    - å…³é”®å­—æœ‰ï¼š`bytes1`ï¼Œ `bytes2`ï¼Œ `bytes3`ï¼Œ ...ï¼Œ `bytes32`ã€‚`byte` æ˜¯ `bytes1` çš„åˆ«å
06. å˜é•¿å­—èŠ‚æ•°ç»„
    - `bytes`, `string` â€”â€”â€”â€”ä¸æ˜¯å€¼ç±»å‹
07. åœ°å€å­—é¢å¸¸æ•°
    - é€šè¿‡äº†åœ°å€æ ¡éªŒå’Œæµ‹è¯•çš„åå…­è¿›åˆ¶å­—é¢å¸¸æ•°å±äº address ç±»å‹
    - **é•¿åº¦åœ¨ 39 åˆ° 41 ä¸ªæ•°å­—çš„**ï¼Œæ²¡æœ‰é€šè¿‡æ ¡éªŒå’Œæµ‹è¯•è€Œäº§ç”Ÿäº†ä¸€ä¸ªè­¦å‘Šçš„åå…­è¿›åˆ¶å­—é¢å¸¸æ•°è§†ä¸ºæ­£å¸¸çš„æœ‰ç†æ•°å­—é¢å¸¸æ•°
    - æ··åˆå¤§å°å†™çš„åœ°å€æ ¡éªŒå’Œæ ¼å¼å®šä¹‰åœ¨**EIP-55**ä¸­
08. æœ‰ç†æ•°å’Œæ•´æ•°å­—é¢å¸¸æ•°
    - æ•°å€¼å­—é¢å¸¸æ•°è¡¨è¾¾å¼æœ¬èº«æ”¯æŒä»»æ„ç²¾åº¦ã€‚è¿™æ„å‘³ç€åœ¨æ•°å€¼å¸¸é‡è¡¨è¾¾å¼ä¸­, è®¡ç®—ä¸ä¼šæº¢å‡ºè€Œé™¤æ³•ä¹Ÿä¸ä¼šæˆªæ–­ã€‚
    - æ•´æ•°å­—é¢å¸¸æ•°å’Œæœ‰ç†æ•°å­—é¢å¸¸æ•°éƒ½å±äºæ•°å€¼å­—é¢å¸¸æ•°ç±»å‹ã€‚
    - æ‰€æœ‰çš„æ•°å€¼å­—é¢å¸¸æ•°è¡¨è¾¾å¼ï¼ˆå³åªåŒ…å«æ•°å€¼å­—é¢å¸¸æ•°å’Œè¿ç®—ç¬¦çš„è¡¨è¾¾å¼ï¼‰éƒ½å±äºæ•°å€¼å­—é¢å¸¸æ•°ç±»å‹ã€‚
    - æ•°å€¼å­—é¢å¸¸æ•°è¡¨è¾¾å¼åªè¦åœ¨éå­—é¢å¸¸æ•°è¡¨è¾¾å¼ä¸­ä½¿ç”¨å°±ä¼šè½¬æ¢æˆéå­—é¢å¸¸æ•°ç±»å‹ã€‚å¦‚ä¸‹ï¼Œç¼–è¯‘ä¸é€šè¿‡ï¼š
        > uint128 a = 1;
        > uint128 b = 2.5 + a + 0.5;
09. å­—ç¬¦ä¸²å­—é¢å¸¸æ•°
10. åå…­è¿›åˆ¶å­—é¢å¸¸æ•°
11. æšä¸¾ç±»å‹
12. å‡½æ•°ç±»å‹
    - å‡½æ•°ç±»å‹æ˜¯ä¸€ç§è¡¨ç¤ºå‡½æ•°çš„ç±»å‹ã€‚å¯ä»¥å°†ä¸€ä¸ªå‡½æ•°èµ‹å€¼ç»™å¦ä¸€ä¸ªå‡½æ•°ç±»å‹çš„å˜é‡ï¼Œä¹Ÿå¯ä»¥å°†ä¸€ä¸ªå‡½æ•°ä½œä¸ºå‚æ•°è¿›è¡Œä¼ é€’ï¼Œè¿˜èƒ½åœ¨å‡½æ•°è°ƒç”¨ä¸­è¿”å›å‡½æ•°ç±»å‹å˜é‡ã€‚å‡½æ•°ç±»å‹æœ‰ä¸¤ç±»ï¼š- å†…éƒ¨ï¼ˆ`internal`ï¼‰ å‡½æ•°å’Œ å¤–éƒ¨ï¼ˆ`external`ï¼‰ å‡½æ•°ï¼š
    - å†…éƒ¨å‡½æ•°åªèƒ½åœ¨å½“å‰ä»£ç å—å†…è°ƒç”¨ï¼ŒåŒ…æ‹¬å†…éƒ¨åº“å‡½æ•°å’Œç»§æ‰¿å¾—å‡½æ•°ä¸­ï¼›å†…éƒ¨å‡½æ•°çš„è°ƒç”¨æ—¶é€šè¿‡è·³è½¬åˆ°å®ƒçš„å…¥å£æ ‡ç­¾æ¥å®ç°ï¼›
    - å¤–éƒ¨å‡½æ•°ç”±ä¸€ä¸ªåœ°å€å’Œä¸€ä¸ªå‡½æ•°ç­¾åç»„æˆï¼Œå¯ä»¥é€šè¿‡å¤–éƒ¨å‡½æ•°è°ƒç”¨ä¼ é€’æˆ–è€…è¿”å›ï¼›
    - **å‡½æ•°ç±»å‹**é»˜è®¤æ˜¯å†…éƒ¨å‡½æ•°ï¼Œå› æ­¤ä¸éœ€è¦å£°æ˜ `internal` å…³é”®å­—ã€‚ ä¸æ­¤ç›¸åçš„æ˜¯ï¼Œåˆçº¦ä¸­çš„**å‡½æ•°æœ¬èº«**é»˜è®¤æ˜¯ `public` çš„ï¼Œåªæœ‰å½“å®ƒè¢«å½“åšç±»å‹åç§°æ—¶ï¼Œé»˜è®¤æ‰æ˜¯å†…éƒ¨å‡½æ•°ï¼›
    - å¦‚æœå¤–éƒ¨å‡½æ•°ç±»å‹åœ¨ Solidity çš„ä¸Šä¸‹æ–‡ç¯å¢ƒä»¥å¤–çš„åœ°æ–¹ä½¿ç”¨ï¼Œå®ƒä»¬ä¼šè¢«è§†ä¸º `function` ç±»å‹ã€‚ è¯¥ç±»å‹**å°†å‡½æ•°åœ°å€ç´§è·Ÿå…¶å‡½æ•°æ ‡è¯†ä¸€èµ·ç¼–ç ä¸ºä¸€ä¸ª bytes24 ç±»å‹**ï¼›
    - `public`ï¼ˆæˆ– `external`ï¼‰å‡½æ•°ä¹Ÿæœ‰ä¸€ä¸ªç‰¹æ®Šçš„æˆå‘˜å˜é‡ç§°ä½œ `selector`ï¼Œå¯ä»¥è¿”å› ABI å‡½æ•°é€‰æ‹©å™¨ï¼›

##### å¼•ç”¨ç±»å‹
###### æ•°æ®ä½ç½®
- æ‰€æœ‰çš„å¤æ‚ç±»å‹ï¼Œå³ ***æ•°ç»„*** å’Œ ***ç»“æ„*** ç±»å‹ï¼Œéƒ½æœ‰ä¸€ä¸ªé¢å¤–å±æ€§ï¼Œâ€œæ•°æ®ä½ç½®â€ï¼Œè¯´æ˜æ•°æ®æ˜¯ä¿å­˜åœ¨ å†…å­˜memoryï¼ˆå¹¶ä¸æ˜¯æ°¸ä¹…å­˜å‚¨ï¼‰ ä¸­è¿˜æ˜¯ å­˜å‚¨storageï¼ˆä¿å­˜çŠ¶æ€å˜é‡çš„åœ°æ–¹ï¼‰ ä¸­ã€‚
- å‡½æ•°å‚æ•°ï¼ˆåŒ…æ‹¬è¿”å›çš„å‚æ•°ï¼‰çš„æ•°æ®ä½ç½®é»˜è®¤æ˜¯ memoryï¼Œ å±€éƒ¨å˜é‡çš„æ•°æ®ä½ç½®é»˜è®¤æ˜¯ storageï¼ŒçŠ¶æ€å˜é‡çš„æ•°æ®ä½ç½®å¼ºåˆ¶æ˜¯ storage ï¼ˆè¿™æ˜¯æ˜¾è€Œæ˜“è§çš„ï¼‰ã€‚
- ä¹Ÿå­˜åœ¨ç¬¬ä¸‰ç§æ•°æ®ä½ç½®ï¼Œ calldata ï¼Œè¿™æ˜¯ä¸€å—åªè¯»çš„ï¼Œä¸”ä¸ä¼šæ°¸ä¹…å­˜å‚¨çš„ä½ç½®ï¼Œç”¨æ¥å­˜å‚¨å‡½æ•°å‚æ•°ã€‚ å¤–éƒ¨å‡½æ•°çš„å‚æ•°ï¼ˆéè¿”å›å‚æ•°ï¼‰çš„æ•°æ®ä½ç½®è¢«å¼ºåˆ¶æŒ‡å®šä¸º calldata ï¼Œæ•ˆæœè·Ÿ memory å·®ä¸å¤šã€‚
- æ•°æ®ä½ç½®çš„æŒ‡å®šéå¸¸é‡è¦ï¼Œå› ä¸ºå®ƒä»¬å½±å“ç€èµ‹å€¼è¡Œä¸ºï¼š åœ¨ å­˜å‚¨storage å’Œ å†…å­˜memory ä¹‹é—´ä¸¤ä¸¤èµ‹å€¼ï¼Œæˆ–è€… å­˜å‚¨storage å‘çŠ¶æ€å˜é‡ï¼ˆç”šè‡³æ˜¯ä»å…¶å®ƒçŠ¶æ€å˜é‡ï¼‰èµ‹å€¼éƒ½ä¼šåˆ›å»ºä¸€ä»½ç‹¬ç«‹çš„æ‹·è´ã€‚ ç„¶è€ŒçŠ¶æ€å˜é‡å‘å±€éƒ¨å˜é‡èµ‹å€¼æ—¶ä»…ä»…ä¼ é€’ä¸€ä¸ªå¼•ç”¨ï¼Œè€Œä¸”è¿™ä¸ªå¼•ç”¨æ€»æ˜¯æŒ‡å‘çŠ¶æ€å˜é‡ï¼Œå› æ­¤åè€…æ”¹å˜çš„åŒæ—¶å‰è€…ä¹Ÿä¼šå‘ç”Ÿæ”¹å˜ã€‚ å¦ä¸€æ–¹é¢ï¼Œä»ä¸€ä¸ª å†…å­˜memory å­˜å‚¨çš„å¼•ç”¨ç±»å‹å‘å¦ä¸€ä¸ª å†…å­˜memory å­˜å‚¨çš„å¼•ç”¨ç±»å‹èµ‹å€¼å¹¶ä¸ä¼šåˆ›å»ºæ‹·è´ã€‚
01. æ•°ç»„
    - ä¸€ä¸ªå…ƒç´ ç±»å‹ä¸º Tï¼Œå›ºå®šé•¿åº¦ä¸º k çš„æ•°ç»„å¯ä»¥å£°æ˜ä¸º T[k]ï¼Œè€ŒåŠ¨æ€æ•°ç»„å£°æ˜ä¸º T[]ï¼›
    - Tä¹Ÿå¯ä»¥æ˜¯ä¸€ä¸ªæ•°ç»„ï¼Œä¸¾ä¸ªä¾‹å­ï¼Œä¸€ä¸ªé•¿åº¦ä¸º 5ï¼Œå…ƒç´ ç±»å‹ä¸º uint çš„åŠ¨æ€æ•°ç»„çš„æ•°ç»„ï¼Œåº”å£°æ˜ä¸º uint[][5]ï¼Œè¦è®¿é—®ç¬¬ä¸‰ä¸ªåŠ¨æ€æ•°ç»„çš„ç¬¬äºŒä¸ªå…ƒç´ ï¼Œä½ åº”è¯¥ä½¿ç”¨ x[2][1];
    - bytes å’Œ string ç±»å‹çš„å˜é‡æ˜¯ç‰¹æ®Šçš„æ•°ç»„ã€‚ bytes ç±»ä¼¼äº byte[]ï¼Œä½†å®ƒåœ¨ calldata ä¸­ä¼šè¢«â€œç´§æ‰“åŒ…â€ã€‚string ä¸ bytes ç›¸åŒï¼Œä½†ï¼ˆæš‚æ—¶ï¼‰ä¸å…è®¸ç”¨é•¿åº¦æˆ–ç´¢å¼•æ¥è®¿é—®ã€‚
    - solæ²¡æœ‰å­—ç¬¦ä¸²æ“ä½œå‡½æ•°ï¼Œä½†æœ‰ç¬¬ä¸‰æ–¹å­—ç¬¦ä¸²åº“
    - å­—ç¬¦ä¸²æ¯”è¾ƒï¼škeccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2))
    - å­—ç¬¦ä¸²è¿æ¥ï¼šstring.concat(s1, s2)
    - bytesè¿˜æ˜¯byte1[]ï¼Ÿ
    - bytes(s), low-level bytes of the utf-8
    - bytes.concatå‡½æ•°å’Œstring.concatå‡½æ•°ï¼šç´§æ‰“åŒ…çš„æ–¹å¼è¿æ¥ä»»æ„æ•°é‡çš„å­—èŠ‚å€¼æˆ–å­—ç¬¦å€¼ï¼Œè¿”å›å•ä¸€çš„byteså’Œstringå†…å­˜æ•°ç»„
    - åˆ†é…å†…å­˜æ•°ç»„
        - ä½¿ç”¨newæ“ä½œç¬¦åˆ›å»º
        - æ•°ç»„å¤§å°ä¸å¯æ”¹å˜
        - å¦‚æœ‰å¿…è¦ï¼Œåªèƒ½åˆ›å»ºä¸€ä¸ªæ–°çš„å†…å­˜æ•°ç»„ï¼Œå¹¶ä¸€ä¸ªä¸ªæ‹·è´å…ƒç´ 
    - æ•°ç»„å­—é¢å¸¸æ•°
        - é™æ€å¤§å°çš„å†…å­˜æ•°ç»„ï¼Œé•¿åº¦å³åˆ—è¡¨å…ƒç´ ï¼ˆè¡¨è¾¾å¼ï¼‰æ•°é‡
        - æ•°ç»„çš„ç±»å‹ä¸åˆ—è¡¨ä¸­ç¬¬ä¸€ä¸ªå…ƒç´ ï¼ˆè¡¨è¾¾å¼ï¼‰ä¸€è‡´ï¼Œå…¶ä»–å…ƒç´ è¦èƒ½éšå¼è½¬æ¢ï¼Œå¦åˆ™æŠ¥é”™
        - [1, 2, 3] is uint8[3] memory, [1, -1] is invalid
    - å›ºå®šå¤§å°çš„å†…å­˜æ•°ç»„ä¸èƒ½èµ‹å€¼ç»™åŠ¨æ€å¤§å°çš„å†…å­˜æ•°ç»„
    - åŠ¨æ€å¤§å°æ•°ç»„çš„èµ‹å€¼éœ€é€ä¸€èµ‹å€¼
    - æˆå‘˜å˜é‡
        - length
        - push(): åŠ¨æ€å­˜å‚¨æ•°ç»„å’Œbytesï¼ˆéstringï¼‰æœ‰è¯¥æˆå‘˜å‡½æ•°ï¼Œé™„åŠ é›¶åˆå§‹åŒ–çš„å…ƒç´ åˆ°æ•°ç»„æœ«å°¾ï¼Œå¹¶è¿”å›å…ƒç´ å¼•ç”¨
            - x.push().t = 2 or x.push() = b
        - push(x): åŠ¨æ€å­˜å‚¨æ•°ç»„å’Œbytesï¼ˆéstringï¼‰æœ‰è¯¥æˆå‘˜å‡½æ•°ï¼Œé™„åŠ ç»™å®šå…ƒç´ åˆ°æ•°ç»„æœ«å°¾ï¼Œæ— è¿”å›
        - pop(): åŠ¨æ€å­˜å‚¨æ•°ç»„å’Œbytesï¼ˆéstringï¼‰æœ‰è¯¥æˆå‘˜å‡½æ•°ï¼Œä»æ•°ç»„æœ«å°¾ç§»é™¤å…ƒç´ ï¼Œéšå¼è°ƒç”¨delete è¢«ç§»é™¤å…ƒç´ ï¼Œæ— è¿”å›
        - push()æœ‰å¸¸é‡çš„æ²¹æ°”æ¶ˆè€—, pop()çš„æ²¹æ°”æ¶ˆè€—ä¾èµ–äºç§»é™¤å…ƒç´ çš„å¤§å°
    - æ‚¬æµ®å¼•ç”¨
        - ä½¿ç”¨å­˜å‚¨æ•°ç»„æ—¶ï¼Œè¦å°å¿ƒ**é¿å…æ‚¬æµ®å¼•ç”¨**
        - åœºæ™¯1ï¼šå­˜å‚¨ä¸€ä¸ªæ•°ç»„å…ƒç´ çš„å¼•ç”¨åˆ°æœ¬åœ°å˜é‡ï¼Œå°”åè°ƒç”¨.pop()ä»æ•°ç»„ä¸­ç§»é™¤äº†è¯¥å…ƒç´ 
        - åœºæ™¯2ï¼šåœ¨å…ƒç»„èµ‹å€¼ä¸­ä½¿ç”¨äº†å¤æ‚çš„è¡¨è¾¾å¼
        - bytesæ•°ç»„å…ƒç´ çš„å¼•ç”¨ï¼Ÿ--***ä¸ºä»€ä¹ˆï¼Ÿ***
    - æ•°ç»„åˆ‡ç‰‡
        - x[start:end]
        - array slices only exist in intermediate expressions.
        - as of now, array slices are only implemented for calldata arrays.
02. ç»“æ„ä½“
    - ç»“æ„ä½“å¯ä»¥ç”¨åœ¨æ˜ å°„å’Œæ•°ç»„ï¼Œä¹Ÿå¯ä»¥åŒ…å«æ˜ å°„å’Œæ•°ç»„
    - ä¸å¯ä»¥åœ¨ç»“æ„ä½“ä¸­åŒ…å«è‡ªèº«ç±»å‹çš„æˆå‘˜
    - åœ¨å‡½æ•°ä¸­ä½¿ç”¨ç»“æ„ä½“ï¼Œç»“æ„ä½“æ˜¯èµ‹å€¼ç»™storageæ•°æ®ä½ç½®çš„æœ¬åœ°å˜é‡ï¼ˆéæ‹·è´ï¼Œä»…å­˜å‚¨å¼•ç”¨ï¼‰ï¼Œæ‰€ä»¥å¯¹å±€éƒ¨å˜é‡çš„æˆå‘˜è®¿é—®å®é™…ä¸Šä¼šè¢«å†™å…¥çŠ¶æ€ï¼›å½“ç„¶ä¹Ÿå¯ä»¥ç›´æ¥è®¿é—®ç»“æ„ä½“çš„æˆå‘˜æ¥èµ‹å€¼
03. æ˜ å°„
    - mapping(KeyType KeyName? => ValueType ValueName?)
    - keyType: å¯ä»¥æ˜¯ä»»ä½•å†…å»ºå€¼ç±»å‹ã€bytesã€stringæˆ–ä»»ä½•åˆçº¦ã€æšä¸¾ç±»å‹ï¼›ç”¨æˆ·è‡ªå®šä¹‰ç±»å‹æˆ–å¤æ‚ç±»å‹ï¼Œå¦‚æ˜ å°„ã€ç»“æ„ä½“ã€æ•°ç»„ä¸å…è®¸ï¼›valueTypeï¼šå¯ä»¥æ˜¯ä»»ä½•ç±»å‹; åå­—æ˜¯å¯é€‰çš„
    - å®ƒä»¬åœ¨å®é™…çš„åˆå§‹åŒ–è¿‡ç¨‹ä¸­åˆ›å»ºæ¯ä¸ªå¯èƒ½çš„keyï¼Œå¹¶å°†å…¶æ˜ å°„åˆ°å­—èŠ‚å½¢å¼å…¨æ˜¯é›¶çš„å€¼ï¼šä¸€ä¸ªç±»å‹çš„é»˜è®¤å€¼ã€‚ç„¶è€Œä¸‹é¢æ˜¯æ˜ å°„ä¸å“ˆå¸Œè¡¨ä¸åŒçš„åœ°æ–¹ï¼šåœ¨æ˜ å°„ä¸­ï¼Œå®é™…ä¸Šå¹¶ä¸å­˜å‚¨keyï¼Œè€Œæ˜¯å­˜å‚¨å®ƒçš„keccak256å“ˆå¸Œå€¼ï¼Œä»è€Œä¾¿äºæŸ¥è¯¢å®é™…çš„å€¼
    - æ­£å› å¦‚æ­¤ï¼Œæ˜ å°„æ²¡æœ‰é•¿åº¦ï¼Œkeyçš„é›†åˆæˆ–valueçš„é›†åˆçš„æ¦‚å¿µ
    - åªæœ‰çŠ¶æ€å˜é‡ï¼ˆæˆ–è€…åœ¨å†…éƒ¨å‡½æ•°ä¸­çš„å¯¹äºå­˜å‚¨å˜é‡çš„å¼•ç”¨ï¼Œæˆ–ä½œä¸ºåº“å‡½æ•°çš„å‚æ•°ï¼‰å¯ä»¥ä½¿ç”¨æ˜ å°„ç±»å‹ã€‚ä¸èƒ½ç”¨ä½œå…¬å…±å¯è§çš„å‡½æ•°çš„å‚æ•°æˆ–è€…è¿”å›å€¼ã€‚å¯¹äºåŒ…å«æ˜ å°„çš„ç»“æ„ä½“å’Œæ•°ç»„åŒæ ·éµå¾ªæ­¤åŸåˆ™
    - public state variable -> getter -> KeyType KeyName -> ValueType ValueName -> array or mapping -> the getter has one parameter for each KeyType, recursively
##### æ“ä½œç¬¦
- ç±»å‹å†³æ–­
- ä¸‰å…ƒè¿ç®—ç¬¦
- å¤åˆè¿ç®— å’Œ è‡ªå¢ã€è‡ªå‡
- delete: æœ‰ç‚¹ç±»ä¼¼ï¼Œèµ‹å€¼ï¼Ÿ 

### solç¬”è®°ï¼ˆenï¼‰
#### å€¼ç±»å‹åŠå¯ç”¨æ“ä½œç¬¦
01. bool
    - å¸ƒå°”å‹
    - value-range: trueã€false
    - operatorsï¼š!, &&, ||, ==, !=
02. int/uint(int256/uint256), int8~int256, uint8~uint256
    - æ•´å‹
    - value-range: type(X).min ~ type(X).max
    - eg: uint32's value range is 0 up to 2**32-1
    - operators: 
        - comparisons: <, <=, ==, !=, >, >=
        - bit: &, |, ^, ~
        - shift: <<, >>
        - arithmetic: +, -, *, /, %, **, unary -
        - two modes: wrapping or unchecked, checked
        - ç§»ä½ï¼šç»“æœå–å†³äºè¿ç®—ç¬¦å·¦è¾¹çš„ç±»å‹ï¼›æŒ‰è´Ÿæ•°ä½ç§»åŠ¨ä¼šå¼•å‘è¿è¡Œæ—¶å¼‚å¸¸ï¼›0.5.0ä¹‹å‰å‘0æˆªæ–­ï¼Œ0.5.0ä¹‹åå‘è´Ÿæ— ç©·æˆªæ–­ã€‚
        - åŠ ã€å‡ã€ä¹˜ï¼šä¼šå­˜åœ¨ä¸Šæº¢ä¸‹æº¢ï¼Œcheckedæ¨¡å¼ä¼šå¼•å‘å¼‚å¸¸ã€‚
        - é™¤æ³•ï¼šé™¤æ³•æ€»æ˜¯ä¼šæˆªæ–­ï¼Œä½†æ“ä½œæ•°éƒ½æ˜¯å­—é¢å¸¸æ•°åˆ™ä¸ä¼šæˆªæ–­ï¼›é™¤æ³•å‘0æˆªæ–­ï¼›é™¤0è¿ç®—ä¼šå¼•å‘å¼‚å¸¸ï¼›é™¤æ³•å”¯ä¸€æº¢å‡ºçš„åœºæ™¯æ˜¯type(int).min/-1ã€‚
        - æ¨¡ï¼šç»“æœå–å†³äºè¿ç®—ç¬¦å·¦è¾¹çš„ç±»å‹ï¼›æ¨¡0è¿ç®—ä¼šå¼•å‘å¼‚å¸¸ï¼›
        - æŒ‡æ•°ï¼šç»“æœå–å†³äºåŸºæ•°ç±»å‹ï¼›ä»…é€‚ç”¨äºæŒ‡æ•°ä¸­çš„æ— ç¬¦å·ç±»å‹ï¼›x\*\*3=>x\*x\*xï¼›0\*\*0ç­‰äº1ã€‚
03. fixed/ufixed(fixed128x18/ufixed128x18)(fixedMxN/ufixedMxN, M: 8~256, N: 0-80)
    - å®šé•¿æµ®ç‚¹å‹
    - solè¿˜æ²¡æœ‰å®Œå…¨æ”¯æŒå®šé•¿æµ®ç‚¹å‹ã€‚å¯ä»¥å£°æ˜å®šé•¿æµ®ç‚¹å‹çš„å˜é‡ï¼Œä½†ä¸èƒ½ç»™å®ƒä»¬èµ‹å€¼æˆ–æŠŠå®ƒä»¬èµ‹å€¼ç»™å…¶ä»–å˜é‡
    - value-range: 
    - operators:
        - comparisons: <, <=, ==, !=, >, >=
        - arithmetic: +, -, *, /, %, unary -
    - æµ®ç‚¹å‹float, double--æ— ã€‚
04. address/address payable
    - 20 byte value
    - conversions: 
        - implicit conversions from address payable to address are allowed
        - explicit conversions to and from address are allowed for: uint160, integer literals, bytes20 and contract type
        - address payable: only expressions of type address and contract-type can
        - bytes32, address(uint160(bytes20(b))), address(uint160(uint256(b)))
    - åœ°å€ç±»å‹æˆå‘˜å˜é‡
        - balanceå’Œtransfer
            > address payable x = payable(0x123);
            > address myAddress = address(this);
            > if (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);
            - å¦‚æœxæ˜¯åˆçº¦å‡½æ•°ï¼Œå®ƒçš„æ¥æ”¶å‡½æ•°æˆ–fallbackå‡½æ•°ï¼ˆå¦‚æœæœ‰çš„è¯ï¼‰ä¼šè·Ÿéštransferè°ƒç”¨ä¸€èµ·æ‰§è¡Œ
        - send
        - call, delegatecall and staticcall
            > bytes memory payload = abi.encodeWithSignature("register(string)", "MyName");
            > (bool success, bytes memory returnData) = address(nameReg).call(payload);
            > require(success);
            - All these functions are low-level functions and should be used with care
            - The regular way to interact with other contracts is to call a function on a contract object (x.f()).
            - gas modifier, value modifier
            > address(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature("register(string)", "MyName"));
        - code and codehash
            - .code -> bytes memory
            - .codehash -> Keccak-256 hash of that code:bytes32
            - note: addr.codehash is cheaper than using keccak256(addr.code)
05. Contract Types
    - Every contract defines its own type: MyContract c
    - conversion:
        - can implicitly convert contracts to contracts they inherit from
        - explicit conversion to and from the address payable: has a receive or payable fallback function
        - explicit conversion to and from the address: does not have a receive or payable fallback function
        - address payable conversion: payable(address(x))
    - The members of contract types are the external functions of the contract including any state variables marked as public
06. bytes1, bytes2, bytes3, â€¦, bytes32
    - operators:
        - comparisons: <, <=, ==, !=, >, >=
        - bit: &, |, ^, ~
        - shift: <<, >>
        - index access: If x is of type bytesI, then ***x[k] for 0 <= k < I*** returns the k th byte
    - members:
        - .length
        - Prior to version 0.8.0, byte used to be an alias for bytes1
07. bytes/string
08. Literals
    - Address Literals
        - Hexadecimal literals that pass the address checksum test(EIP-55)
        - 39 and 41 digits long and **do not pass the checksum test produce an error**
    - Rational and Integer Literals
        - æ•´å‹å­—é¢å¸¸æ•°: 0-9ç»„æˆçš„æ•°å­—åºåˆ—
        - åˆ†æ•°å­—é¢å¸¸æ•°ï¼šå°æ•°ç‚¹.ä¸”ä¹‹åè‡³å°‘ä¸€ä½æ•°å­—ï¼ˆå¦‚.1, 1.3ï¼‰
        - ç§‘å­¦è®¡æ•°çš„å­—é¢å¸¸æ•°ï¼šMeE => M * 10**Eï¼Œå°¾æ•°å¯ä»¥æ˜¯å°æ•°ï¼ŒæŒ‡æ•°å¿…é¡»æ˜¯æ•´æ•°
        - ä¸‹åˆ’çº¿çš„ä½¿ç”¨ï¼Œå¢åŠ å­—é¢å¸¸æ•°å¯è¯»æ€§
        - æ•°å€¼å­—é¢å¸¸æ•°è¡¨è¾¾å¼å¯ä»¥ä¿ç•™ä»»æ„ç²¾åº¦ç›´åˆ°è¢«è½¬æ¢æˆéå­—é¢ç±»å‹ï¼Œå³ä¸ä¼šå‘ç”Ÿæº¢å‡ºæˆ–è€…æˆªæ–­
        - å¤§éƒ¨åˆ†æ“ä½œç¬¦åº”ç”¨åˆ°å­—é¢å¸¸æ•°ç»“æœä¹Ÿæ˜¯å­—é¢å¸¸æ•°ï¼Œæœ‰ä¸¤ç±»ä¸ç¬¦åˆè¿™ç§æƒ…å½¢ï¼š
            - ä¸‰å…ƒè¿ç®—ç¬¦ï¼š... ? ... : ...
            - æ•°ç»„è£å‰ªï¼š <array>[<index>]
    - String Literals and Types
        - å•å¼•å·æˆ–åŒå¼•å·å¼•èµ·æ¥çš„å­—ç¬¦ä¸²
        - å¯éšå¼è½¬æ¢ï¼šbytes1~bytes32, bytes, string
        - æ”¯æŒè½¬ä¹‰å­—ç¬¦å¦‚ï¼š\n, \xNN, \uNNNN
    - Unicode Literals
        > string memory a = unicode"Hello ğŸ˜ƒ";
    - Hexadecimal Literals
        - hex"001122FF", hex'0011_22_FF'
09. Enums
    - They are explicitly convertible to and from all integer types but implicit conversion is not allowed
    - type(NameOfEnum).min and type(NameOfEnum).max
10. User-defined Value Types
    - type C is V

#### å•ä½å’Œå…¨å±€å˜é‡

### åº”ç”¨äºŒè¿›åˆ¶æ¥å£
01. å‡½æ•°é€‰æ‹©å™¨
    - ä¸€ä¸ªå‡½æ•°è°ƒç”¨æ•°æ®çš„å‰4å­—èŠ‚ï¼ŒæŒ‡å®šäº†è¦è°ƒç”¨çš„å‡½æ•°ã€‚è¿™å°±æ˜¯æŸä¸ªå‡½æ•°ç­¾åçš„Keccak(SHA-3)å“ˆå¸Œçš„å‰4ä¸ªå­—èŠ‚ï¼ˆé«˜ä½åœ¨å·¦çš„å¤§ç«¯åºï¼‰
02. å‚æ•°ç¼–ç 
    - ç¬¬5ä¸ªå­—èŠ‚å¼€å§‹æ—¶è¢«ç¼–ç çš„å‚æ•°
03. ç±»å‹
    - uint<M>, int<M>, address, uint256(uint), int256(int), uint8(bool), finxed<M>x<N>, ufixed<M>x<N>, fixed128x18(fixed), ufixed128x18(ufixed), bytes<M>, function(bytes24), <type>[M], bytes, string, <type>[], (T1,T2,...,Tn)
    - ABIå…ƒç»„æ—¶ç”¨solçš„structsç¼–ç å¾—åˆ°
04. ç¼–ç çš„å½¢å¼åŒ–è¯´æ˜
    - è¯»å–æ¬¡æ•°å–å†³äºå‚æ•°æ•°ç»„ç»“æ„ä¸­çš„æœ€å¤§æ·±åº¦
    - ä¸€ä¸ªå˜é‡æˆ–æ•°ç»„å…ƒç´ çš„æ•°æ®ï¼Œä¸ä¼šè¢«æ’å…¥å…¶ä»–çš„æ•°æ®ï¼Œå¹¶ä¸”æ˜¯å¯ä»¥å†å®šä½çš„ï¼ˆç›¸å¯¹â€œåœ°å€â€ï¼‰
    - é™æ€ç±»å‹ä¼šè¢«ç›´æ¥ç¼–ç ï¼›åŠ¨æ€ç±»å‹ä¼šåœ¨å½“å‰æ•°æ®å—ä¹‹åå•ç‹¬åˆ†é…çš„ä½ç½®è¢«ç¼–ç 
    - åŠ¨æ€ï¼šbytes, string, ä»»æ„ç±»å‹Tçš„å˜æˆæ•°ç»„T[\], ä»»æ„åŠ¨æ€ç±»å‹Tçš„å®šé•¿æ•°ç»„T[k], ç”±åŠ¨æ€çš„Tiæ„æˆçš„å…ƒç»„
    - len(enc(X)), encå®šä¹‰ä¸ºä¸€ä¸ªç”±ABIç±»å‹åˆ°äºŒè¿›åˆ¶å­—ç¬¦ä¸²çš„å€¼çš„æ˜ å°„ï¼ŒXæ˜¯åŠ¨æ€çš„ï¼Œlen(enc(X))æ‰ä¼šä¾èµ–äºX
    - å¯¹ä»»æ„Xï¼Œlen(enc(X))éƒ½æ˜¯32çš„å€æ•°
05. å‡½æ•°é€‰æ‹©å™¨ä½•å‚æ•°ç¼–ç 
    - function_selector(f) enc((a_1, ..., a_n)), enc((v_1, ..., v_k))
    - å­—èŠ‚æ•°åç§»é‡æ˜¯ä»–ä»¬çš„æ•°æ®åŒºåŸŸçš„èµ·å§‹ä½ç½®

NatSpec
Yul